<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <title>Just intonation pitch lattice (Primes up to 31)</title>
  <style>
    /* ------------------- BASE & LAYOUT ------------------- */
    body { 
        font-family: 'Helvetica Neue', Helvetica, Arial, sans-serif; 
        background: #f4f7f9; 
        color: #333; 
        position: relative; 
        margin: 0;
        padding-top: 80px; 
        padding-right: 300px; 
        overflow: hidden;
    }
    
    #header {
        position: fixed; 
        top: 0;
        left: 0;
        right: 300px; 
        background: #ffffff;
        padding: 10px 20px;
        border-bottom: 1px solid #ddd;
        box-shadow: 0 2px 4px rgba(0,0,0,0.05); 
        z-index: 1000;
        box-sizing: border-box; 
    }

    #container { 
        height: calc(100vh - 80px);
        overflow: hidden;
        position: relative;
    }

    canvas {
        position: absolute;
        top: 0;
        left: 0;
        background: #fff;
    }
    
    /* FONT WEIGHT STYLES (BOLD) */
    h1 { font-size: 1.5em; margin: 0; font-weight: 700; }
    h2 { 
        font-size: 1.1em; 
        margin-top: 0; 
        margin-bottom: 8px; 
        color: #1e601e; 
        font-weight: 700; 
    }
    button { 
        font-weight: 700; 
        margin-top: 8px; 
    }

    /* FONT WEIGHT STYLES (LIGHT) */
    #header p { margin: 5px 0 0 0; font-size: 0.87em; color: #555; font-weight: 300; }
    .control-group p { font-weight: 300; font-size: 0.87em; margin: 4px 0 8px 0; }
    label { 
        display: block; 
        margin-top: 8px; 
        font-size: 0.87em; 
        font-weight: 300; 
        color: #444;
    }
    label span { font-weight: 300; }
    select, input[type="text"] { font-weight: 300; }
    
    .checkbox-group {
        display: flex;
        flex-wrap: wrap; 
        gap: 8px 12px;
    }
    .checkbox-group label { 
        display: flex;
        align-items: center;
        margin-top: 0;
        font-weight: 300; 
        cursor: pointer;
    }
    .checkbox-group input[type="radio"],
    .checkbox-group input[type="checkbox"] {
        margin-right: 5px;
    }

    /* ------------------- CONTROL PANEL STYLING ------------------- */
    #control-panel { 
        position: fixed; 
        top: 0;
        right: 0;
        width: 300px; 
        padding: 20px; 
        background: #ffffff;
        height: 100vh; 
        overflow-y: auto; 
        box-shadow: -2px 0 8px rgba(0,0,0,0.1); 
        z-index: 100;
        box-sizing: border-box;
    }

    .control-group { 
        margin-bottom: 16px; 
        padding-bottom: 16px; 
        border-bottom: 1px solid #eee;
    }
    .control-group:last-child { border-bottom: none; padding-bottom: 0; }
    
    input[type="range"] { 
        width: 100%; 
        margin: 4px 0; 
        -webkit-appearance: none; appearance: none;
        height: 4px; background: #ddd; border-radius: 2px;
    }
    
    .display-nodes-container {
        display: flex;
        gap: 20px;
    }
    .display-nodes-container > div:first-child { flex: 1.2; }
    .display-nodes-container > div:last-child { flex: 1; }
    
    #prime-filters-container .grid-label {
        margin-top: 0;
    }
    .prime-checkbox-grid {
        display: grid;
        grid-template-columns: 1fr 1fr;
        gap: 4px 10px;
        margin-top: 5px;
    }
    .prime-checkbox-grid label {
        margin-top: 0;
        display: flex;
        align-items: center;
    }
    select#prime-limit-select, select#parent-limit-select, #waveform {
        width: 100%;
        margin-top: 5px;
    }

    /* ------------------- ACCORDION FOR CONTROL PANEL ------------------- */
    .control-group > h2 {
        cursor: pointer;
        user-select: none;
        position: relative;
        padding-right: 1.5em; 
    }
    .control-group > h2::after {
        content: '▾';
        position: absolute;
        right: 0;
        top: 50%;
        transform: translateY(-50%);
        font-size: 0.9em;
        color: #888;
    }
    .control-group.collapsed > h2::after {
        content: '▸';
    }
    .control-group.collapsed > .control-content {
        display: none;
    }

  </style>
</head>
<body>
  
  <div id="header">
    <h1>Just intonation pitch lattice (Primes up to 31)</h1>
    <p>Click a node (or the octave selectors to the right of each node) to play pitches. All nodes default to within one octave above the fundamental. Use the control panel to control the sound, how pitches are displayed, which primes are displayed, and to locate specific intervals. Copyright © Alexander Garsden 2025.</p>
  </div>

  <div id="container">
    <canvas id="lattice"></canvas>
  </div>

  <div id="control-panel">
    
    <div class="control-group">
        <h2>Lattice View</h2>
        <div class="control-content">
            <label for="zoom-slider">Zoom Level: <span id="zoom-val">1.00</span>x</label>
            <input type="range" id="zoom-slider" min="0.1" max="2.6" step="0.05" value="1.0">
        </div>
    </div>

    <div class="control-group">
        <h2>Sound Controls</h2>
        <div class="control-content">
            <div id="top-sound-row" style="display: flex; gap: 15px; align-items: flex-end; margin-bottom: 6px;">
                <div style="flex: 1.2;">
                    <label for="waveform" style="margin-top:0;">Waveform:</label>
                    <select id="waveform">
                        <option value="sine" selected>Sine</option>
                        <option value="square">Square</option>
                        <option value="triangle">Triangle</option>
                        <option value="sawtooth">Sawtooth</option>
                    </select>
                </div>
                <div style="flex: 1;">
                    <label for="volume" style="margin-top:0;">Gain: <span id="volume-val">0.05</span></label>
                    <input type="range" id="volume" min="0" max="0.5" step="0.01" value="0.05">
                </div>
            </div>
            <div id="slider-grid" style="display: grid; grid-template-columns: 1fr 1fr; gap: 0 15px;">
                <div>
                    <label for="attack">Attack: <span id="attack-val">0.50</span>s</label>
                    <input type="range" id="attack" min="0.01" max="2.0" step="0.01" value="0.50">
                    <label for="decay">Release: <span id="decay-val">1.00</span>s</label>
                    <input type="range" id="decay" min="0.01" max="4.0" step="0.01" value="1.00">
                </div>
                <div>
                    <label for="filter-freq">LPF (Hz): <span id="filter-freq-val">5000</span></label>
                    <input type="range" id="filter-freq" min="100" max="20000" step="10" value="5000">
                    <label for="filter-q">Resonance (Q): <span id="filter-q-val">1.0</span></label>
                    <input type="range" id="filter-q" min="0.1" max="20" step="0.1" value="1.0">
                </div>
            </div>
            <button onclick="deactivateAll()" style="width: 100%;">Stop All Sound</button>
        </div>
    </div>
    
    <div class="control-group">
        <h2>Pitch Display & Fundamental</h2>
        <div class="control-content">
            <label>Pitch Display:</label>
            <div class="checkbox-group">
                <label><input type="radio" name="pitch-display" value="hz" id="display-hz" checked> Hz</label>
                <label><input type="radio" name="pitch-display" value="pitch" id="display-pitch"> Pitch Name (+ Cents)</label>
            </div>
            <label for="fundamental-input" id="fundamental-label">Fundamental (Hz):</label>
            <input type="text" id="fundamental-input" value="440" onchange="setFundamental()">
            <p>*Pitch example: A4 +0c (Octave 4 assumed if not specified, e.g. A +0c)</p>
        </div>
    </div>

    <div class="control-group">
        <h2>Displayed Nodes</h2>
        <div class="control-content">
            <div class="display-nodes-container">
                <div>
                    <label for="prime-limit-select" style="margin-top:0;">Prime Limit:</label>
                    <select id="prime-limit-select">
                        <option value="custom">Custom</option>
                        <option value="3">3-limit</option>
                        <option value="5">5-limit</option>
                        <option value="7" selected>7-limit</option>
                        <option value="11">11-limit</option>
                        <option value="13">13-limit</option>
                        <option value="17">17-limit</option>
                        <option value="19">19-limit</option>
                        <option value="23">23-limit</option>
                        <option value="29">29-limit</option>
                        <option value="31">31-limit</option>
                    </select>

                    <label for="parent-limit-select">Generate primes >5 from:</label>
                    <select id="parent-limit-select">
                        <option value="5-limit" selected>5-limit</option>
                        <option value="all">Primes >5</option>
                    </select>
                </div>
                <div id="prime-filters-container">
                    <label class="grid-label" style="margin-top:0;">Individual Primes:</label>
                    <div id="prime-filters" class="prime-checkbox-grid">
                        <label><input type="checkbox" data-prime="3" checked> 3</label>
                        <label><input type="checkbox" data-prime="11"> 11</label>
                        <label><input type="checkbox" data-prime="5" checked> 5</label>
                        <label><input type="checkbox" data-prime="13"> 13</label>
                        <label><input type="checkbox" data-prime="7" checked> 7</label>
                        <label><input type="checkbox" data-prime="17"> 17</label>
                        <label><input type="checkbox" data-prime="19"> 19</label>
                        <label><input type="checkbox" data-prime="23"> 23</label>
                        <label><input type="checkbox" data-prime="29"> 29</label>
                        <label><input type="checkbox" data-prime="31"> 31</label>
                    </div>
                </div>
            </div>
            <div class="checkbox-group" style="margin-top: 12px;">
                <label><input type="checkbox" id="show-harmonics" checked> Harmonics</label>
                <label><input type="checkbox" id="show-subharmonics" checked> Subharmonics</label>
            </div>
        </div>
    </div>

    <div class="control-group">
        <h2>Locate Pitch Class</h2>
        <div class="control-content">
            <p>Highlight all nodes within a specific pitch class range (ignoring octaves).</p>
            
            <div style="display: flex; align-items: center; gap: 5px; margin-bottom: 8px;">
                <div style="flex:1;">
                    <label for="pitch-range-min" style="margin-top:0;">Min:</label>
                    <input type="text" id="pitch-range-min" placeholder="e.g. C -10c" style="width:100%;">
                </div>
                <div style="flex:1;">
                    <label for="pitch-range-max" style="margin-top:0;">Max:</label>
                    <input type="text" id="pitch-range-max" placeholder="e.g. C +10c" style="width:100%;">
                </div>
            </div>

            <div style="display: flex; gap: 10px; margin-top: 2px;">
                <button id="locate-pitch-btn" style="flex: 1; margin-top: 0;">Find</button>
                <button id="clear-pitch-btn" style="flex: 1; margin-top: 0;">Clear</button>
            </div>
        </div>
    </div>

    <div class="control-group">
        <h2>Locate Interval</h2>
        <div class="control-content">
            <p>Find pairs of nodes matching an interval. Use a preset or enter a ratio manually.</p>
            <div id="locate-interval-container" style="display: flex; flex-direction: column; gap: 6px; margin-top: 5px;">
                <label for="interval-select" style="margin-top:0; margin-bottom:-4px;">Presets:</label>
                <select id="interval-select" style="width: 100%;"></select>
                
                <label for="interval-num1" style="margin-top:6px; margin-bottom:-4px;">Manual Ratio:</label>
                <div id="manual-interval-inputs" style="display: flex; align-items: center; gap: 5px;">
                    <input type="text" id="interval-num1" placeholder="e.g. 3" style="text-align: center; font-weight: 300; width: 100%;">
                    <span style="font-weight: bold; color: #555;">:</span>
                    <input type="text" id="interval-num2" placeholder="e.g. 2" style="text-align: center; font-weight: 300; width: 100%;">
                </div>
                
                <div style="display: flex; gap: 10px; margin-top: 2px;">
                    <button id="locate-interval-btn" style="flex: 1; margin-top: 0;">Find</button>
                    <button id="clear-interval-btn" style="flex: 1; margin-top: 0;">Clear</button>
                </div>
            </div>
        </div>
    </div>

  </div>

  <script>
    /* 1. GLOBAL STATE & AUDIO SETUP */
    const AudioContext = window.AudioContext || window.webkitAudioContext;
    const audioCtx = new AudioContext();
    const masterGain = audioCtx.createGain();
    masterGain.gain.value = 0.05; 
    const lowPassFilter = audioCtx.createBiquadFilter();
    lowPassFilter.type = 'lowpass';
    lowPassFilter.frequency.setValueAtTime(5000, audioCtx.currentTime); 
    lowPassFilter.Q.setValueAtTime(1.0, audioCtx.currentTime); 
    lowPassFilter.connect(masterGain);
    masterGain.connect(audioCtx.destination);
    
    let fundamental = 440;
    let waveform = 'sine';
    let attackTime = 0.5;
    let releaseTime = 1.0;
    const activePrimes = new Set([3, 5, 7]); 
    let displayMode = 'hz'; 
    let zoomLevel = 0.7;
    let pan = { x: 0, y: 0 };
    let showHarmonics = true;
    let showSubharmonics = true;
    
    let hoveredNode = null;
    let hoveredOctave = { node: null, octaveIndex: -1 };
    let highlightedIntervals = [];
    let highlightedPitchClasses = []; 

    /* 2. UTILITY FUNCTIONS */
    function gcd(a,b){ return b===0?a:gcd(b,a%b); }
    function simplifyFraction(n,d){ const g=gcd(Math.round(n),Math.round(d)); return [Math.round(n)/g,Math.round(d)/g]; }
    function normalizeOctave(n, d){ let num = Math.round(n); let den = Math.round(d); while(num / den >= 2) den *= 2; while(num / den < 1) num *= 2; return [num, den]; }
    function fractionLabel(n,d){ const [num,den]=simplifyFraction(n,d); return `${num}/${den}`; }
    function primeFactors(n){ const f=[]; let num=n; let d=2; while(num>1 && d<=num){ if(num%d===0){ f.push(d); num/=d; } else d++; } return f; }
    function ratioPrimeFactors([n,d]){ const nF=primeFactors(n); const dF=primeFactors(d); return [...new Set([...nF,...dF])].sort((a,b)=>a-b); }
    function getRatioPrimeFactorsWithMultiplicity([n, d]) { return [...primeFactors(n), ...primeFactors(d)].filter(p => p > 2); }
    const PITCH_NAMES = ["C", "C#", "D", "D#", "E", "F", "F#", "G", "G#", "A", "A#", "B"];
    const C4_FREQ = 440 * Math.pow(2, -9/12); 
    
    // UPDATED helper: Robustly parses "Note + Cents" including optional spaces and 'c' suffix
    function parsePitchClassToCents(pS) {
        // Matches: Note(with opt #), optional spaces, optional (+/- digits), optional spaces, optional 'c'
        const m = pS.match(/([A-G]#?)\s*([+\-]?\d+)?\s*c?/i);
        if(!m) return null;
        const [, n, cS] = m;
        let pI = PITCH_NAMES.indexOf(n.toUpperCase());
        if(pI === -1) return null;
        
        const centsFromNote = pI * 100;
        const centsOffset = cS ? parseInt(cS) : 0;
        
        // Normalize to 0-1200 range
        let totalCents = (centsFromNote + centsOffset) % 1200;
        if (totalCents < 0) totalCents += 1200;
        return totalCents;
    }

    function freqToAbsoluteCents(freq) {
        if (freq <= 0) return 0;
        const ratio = freq / C4_FREQ;
        const semitones = 12 * Math.log2(ratio);
        let cents = (semitones * 100) % 1200;
        if (cents < 0) cents += 1200;
        return cents;
    }

    function freqToAbsolutePitchName(freq) {
        if (freq <= 0) return "0 Hz"; 
        const r=freq/C4_FREQ; const tS=12*Math.log2(r); const nS=Math.round(tS);
        const pI=(nS % 12 + 12)%12; 
        const o=4+Math.floor(nS/12); 
        const eF=C4_FREQ*Math.pow(2,nS/12);
        const c=1200*Math.log2(freq/eF); 
        const pN=PITCH_NAMES[pI]; 
        const cS=c.toFixed(0);
        return `${pN}${o} ${cS>=0?'+':''}${cS}c`; 
    }

    function freqToPitchClass(freq) {
        if (freq <= 0) return "0 Hz"; 
        const r=freq/C4_FREQ; const tS=12*Math.log2(r); const nS=Math.round(tS);
        const pI=(nS % 12 + 12)%12; 
        const eF=C4_FREQ*Math.pow(2,nS/12);
        const c=1200*Math.log2(freq/eF); 
        const pN=PITCH_NAMES[pI]; 
        const cS=c.toFixed(0);
        return `${pN} ${cS>=0?'+':''}${cS}c`;
    }
    
    function pitchNameToFreq(pS) {
        const m=pS.match(/([A-G]#?)([0-9]?)\s*([+\-]\d+)c?/i); 
        if(!m)return null; 
        const [, n, oS, cS] = m;
        const o = oS && oS.length > 0 ? parseInt(oS) : 4; 
        const c=parseInt(cS); 
        let pI=PITCH_NAMES.indexOf(n.toUpperCase()); 
        if(pI===-1)return null;
        const tI=(o*12)+pI-48; 
        const eF=C4_FREQ*Math.pow(2,tI/12); 
        return eF*Math.pow(2,c/1200);
    }
    
    function shouldNodeBeVisible(node) {
        if (fractionLabel(node.ratio[0], node.ratio[1]) === '1/1') return true;
        if (node.octaveStates.some(o => o !== null)) return true;

        const numPrimes = primeFactors(node.ratio[0]).filter(p => p !== 2);
        const denPrimes = primeFactors(node.ratio[1]).filter(p => p !== 2);
        
        if (!showSubharmonics && numPrimes.length > 0) return false; 
        if (!showHarmonics && denPrimes.length > 0) return false;  

        const generationMode = document.getElementById('parent-limit-select').value;
        if (generationMode === '5-limit') {
            const highPrimesCount = node.non2Primes_withMultiplicity.filter(p => p > 5).length;
            if (highPrimesCount > 1) return false;
        }

        const uniqueNon2Primes = node.primes.filter(p => p > 2);
        return uniqueNon2Primes.every(p => activePrimes.has(p));
    }
    function getMaxPrime(node) { return node.primes.filter(p => p > 2).reduce((max, p) => Math.max(max, p), 1); }
    function getHighestPrimeLimit(node) {
        if (fractionLabel(node.ratio[0],node.ratio[1])==='1/1') return 1; const mP=node.primes.filter(p=>p>2).reduce((m,p)=>Math.max(m,p),3);
        if(mP>=31)return 31; if(mP>=29)return 29; if(mP>=23)return 23; if(mP>=19)return 19; if(mP>=17)return 17;
        if(mP>=13)return 13; if(mP>=11)return 11; if(mP>=7)return 7; if(mP>=5)return 5; return 3; 
    }
    function isFactorRelated(a,b,factor){
     const eps=1e-6; const r=(a.ratio[0]/a.ratio[1])/(b.ratio[0]/b.ratio[1]); 
     const k1=Math.round(Math.log2(factor/r)); if(Math.abs(r*Math.pow(2,k1)-factor)<eps) return true;
     const k2=Math.round(Math.log2((1/factor)/r)); if(Math.abs(r*Math.pow(2,k2)-(1/factor))<eps) return true;
     return false;
    }
    
    function normalizeIntervalRatio(n, d) {
        if (n === 0 || d === 0) return [0, 0];
        let num = Math.abs(n);
        let den = Math.abs(d);
        while (num > 0 && num % 2 === 0) num /= 2;
        while (den > 0 && den % 2 === 0) den /= 2;
        const commonDivisor = gcd(num, den);
        num /= commonDivisor;
        den /= commonDivisor;
        return num < den ? [num, den] : [den, num];
    }


    /* 3. LATTICE PARAMETERS & DATA */
    const latticeRange = { x: [-4, 4], y: [-2, 2] }; 
    const canvas = document.getElementById("lattice"); const ctx = canvas.getContext("2d");
    const WORLD_WIDTH = 4000; const WORLD_HEIGHT = 2600; 
    const spacing = 480; const centerX = WORLD_WIDTH / 2; const centerY = WORLD_HEIGHT / 2;
    const NODE_RADIUS = 20 * (2 / 3); const LABEL_Y_OFFSET = 25;
    const OCTAVE_MULTIPLIERS = [4, 2, 1, 0.5, 0.25];
    const OCTAVE_MULTIPLIER_FRACS = [[4, 1], [2, 1], [1, 1], [1, 2], [1, 4]];
    const OCTAVE_SELECTOR_X_OFFSET = 24; const OCTAVE_SELECTOR_Y_STEP = 10 * (2 / 3); const OCTAVE_SELECTOR_RADIUS = 2;
    
    const P_VECTORS = (() => {
        const rad = (deg) => deg * Math.PI / 180;
        const vectors = {
            7:  { r: 0.64, a: 20 }, 11: { r: 0.64, a: 70 },
            13: { r: 0.70, a: 40 }, 17: { r: 0.17, a: 50 },
            19: { r: 0.33, a: 30 }, 23: { r: 0.33, a: 60 },
            29: { r: 0.25, a: 10 }, 31: { r: 0.25, a: 80 }
        };
        
        const finalVectors = { 3: { x: 1, y: 0 }, 5: { x: 0, y: 1 } };
        for(const p in vectors) {
            const { r, a } = vectors[p];
            finalVectors[p] = { x: r * Math.cos(rad(a)), y: r * Math.sin(rad(a)) };
        }
        return finalVectors;
    })();

    const PRESET_INTERVALS = {
        "Pythagorean/3-Limit": {
            "Perfect 5ths (3:2) & 4ths (4:3)": "3/2",
        },
        "5-Limit (Ptolemaic)": {
            "Major 3rds (5:4) & minor 6ths (8:5)": "5/4",
            "Minor 3rds (6:5) & major 6ths (5:3)": "6/5",
            "Major Limma (135:128)": "135/128",
            "Just Chromatic Semitone (25:24)": "25/24",
            "Greater Diesis (648:625)": "648/625",
            "Lesser Diesis (128:125)": "128/125",
        },
        "7-Limit (Septimal)": {
            "Harmonic Seventh (7:4)": "7/4",
            "Septimal Tritone (7:5)": "7/5",
            "Septimal Minor Third (7:6)": "7/6",
            "Septimal Quartertone (36:35)": "36/35",
        },
        "11-Limit (Undecimal)": {
            "Undecimal Tritone (11:8)": "11/8",
            "Undecimal Supermajor Second (11:9)": "11/9",
            "Undecimal Quartertone (33:32)": "33/32",
        },
        "Commas & Micro-intervals": {
            "Septimal Diesis (49:48)": "49/48",
            "Septimal Comma (64:63)": "64/63",
            "Syntonic Comma (81:80)": "81/80",
            "Diaschisma (2048:2025)": "2048/2025",
            "Septimal Kleisma (225:224)": "225/224",
            "Breedsma (2401:2400)": "2401/2400",
            "Ragisma (4375:4374)": "4375/4374",
        }
    };

    /* 4. NODE GENERATION */
    let nodes;
    let existingRatios;

    function generateLatticeNodes(generationMode = 'all', nodesToPreserve = []) {
        const newNodes = []; const newRatios = new Map(); const ratioKey = r => r.join(',');
        nodesToPreserve.forEach(node => { const key = ratioKey(node.ratio); if (!newRatios.has(key)) { newNodes.push(node); newRatios.set(key, node); }});
        const createNode = (ratio, x, y) => {
            const key = ratioKey(ratio); if (newRatios.has(key)) return newRatios.get(key);
            const newNode = { ratio, x, y, primes: ratioPrimeFactors(ratio), non2Primes_withMultiplicity: getRatioPrimeFactorsWithMultiplicity(ratio), simplicityScore: ratio[0]*ratio[1], octaveStates: new Array(5).fill(null) };
            newNodes.push(newNode); newRatios.set(key, newNode); return newNode;
        };
        const baseGridSnapshot = [];
        for (let c3=latticeRange.x[0]; c3<=latticeRange.x[1]; c3++) {
            for (let c5=latticeRange.y[0]; c5<=latticeRange.y[1]; c5++) {
                const n3=c3>0?3**c3:1; const d3=c3<0?3**(-c3):1; const n5=c5>0?5**c5:1; const d5=c5<0?5**(-c5):1;
                const r=normalizeOctave(n3*n5,d3*d5);
                const x=centerX+(c3*P_VECTORS[3].x*spacing)+(c5*P_VECTORS[5].x*spacing);
                const y=centerY-((c3*P_VECTORS[3].y*spacing)+(c5*P_VECTORS[5].y*spacing));
                baseGridSnapshot.push(createNode(r,x,y));
            }
        }
        const expand = (base, prime) => {
            const v=P_VECTORS[prime]; const created=[];
            base.forEach(pN => {
                const uR=normalizeOctave(...simplifyFraction(pN.ratio[0]*prime,pN.ratio[1]));
                const uN=createNode(uR, pN.x+v.x*spacing, pN.y-v.y*spacing); if(uN)created.push(uN);
                const dR=normalizeOctave(...simplifyFraction(pN.ratio[0],pN.ratio[1]*prime));
                const dN=createNode(dR, pN.x-v.x*spacing, pN.y+v.y*spacing); if(dN)created.push(dN);
            });
            return created;
        };
        const hP=[7,11,13,17,19,23,29,31]; 
        if(generationMode==='5-limit'){hP.forEach(p=>{expand(baseGridSnapshot,p);});}
        else{ const fOS=[]; hP.forEach(p=>{fOS.push(...expand(baseGridSnapshot,p));}); hP.forEach(p=>{expand(fOS,p);}); }
        newNodes.sort((a,b)=>b.simplicityScore-a.simplicityScore);
        return {nodes:newNodes, existingRatios:newRatios};
    }

    /* 5. CANVAS DRAWING AND INTERACTION LOGIC */
    const NODE_COLORS = {
        1:{p:'#ccc',a:'#000'}, 3:{p:'#b3d6b3',a:'#1e601e'}, 5:{p:'#c3cde6',a:'#191970'},
        7:{p:'#e0b3e0',a:'#800080'}, 11:{p:'#ffb3b3',a:'#ff0000'}, 13:{p:'#e5c9b3',a:'#a0522d'},
        17:{p:'#b3e5e5',a:'#008080'}, 19:{p:'#a0d6b4', a: '#2E8B57' }, 23:{p:'#DAA520',a:'#b8860b'},
        29:{p:'#e5b3b3',a:'#b22222'}, 31:{p:'#b3cce5',a:'#0047ab'}
    };
    const LINE_COLORS = { dark: '#666', light: '#ddd' };
    
    function drawLattice() {
        requestAnimationFrame(() => {
            const dpr = window.devicePixelRatio || 1; const r = canvas.getBoundingClientRect();
            ctx.clearRect(0,0,r.width*dpr,r.height*dpr); ctx.save(); ctx.scale(dpr,dpr); 
            ctx.translate(r.width/2+pan.x, r.height/2+pan.y); ctx.scale(zoomLevel,zoomLevel); ctx.translate(-centerX,-centerY);
            const aP=[3,5,7,11,13,17,19,23,29,31]; const sMDS=spacing*1.2*spacing*1.2;
            let vN = nodes.filter(shouldNodeBeVisible);
            const pM = new Map();
            for(const n of [...vN].reverse()){const pK=`${n.x.toFixed(3)},${n.y.toFixed(3)}`;if(!pM.has(pK)){pM.set(pK,n);}}
            const nTR = Array.from(pM.values());
            
            // Draw Lines
            for(let i=0;i<nTR.length;i++){
                for(let j=i+1;j<nTR.length;j++){
                    const f=nTR[i],g=nTR[j]; if(Math.pow(f.x-g.x,2)+Math.pow(f.y-g.y,2)>sMDS)continue;
                    for(const fac of aP){if(isFactorRelated(f,g,fac)){let c=LINE_COLORS.light;if(fac<=5&&getMaxPrime(f)<7&&getMaxPrime(g)<7){c=LINE_COLORS.dark;}
                    ctx.beginPath();ctx.strokeStyle=c;ctx.lineWidth=1;ctx.moveTo(f.x,f.y);ctx.lineTo(g.x,g.y);ctx.stroke();break;}}}}
            
            // Draw Nodes
            for(const n of nTR){
                const iAP=n.octaveStates.some(o=>o!==null); const l=getHighestPrimeLimit(n); const cS=NODE_COLORS[l];
                
                // Highlight Pitch Classes (Blue Halo)
                if (highlightedPitchClasses.includes(n)) {
                    ctx.beginPath();
                    ctx.arc(n.x, n.y, NODE_RADIUS + 4, 0, 2*Math.PI);
                    ctx.fillStyle = 'rgba(0, 123, 255, 0.4)'; // Translucent blue
                    ctx.fill();
                    ctx.strokeStyle = '#007bff'; // Solid blue border
                    ctx.lineWidth = 2;
                    ctx.stroke();
                }

                ctx.beginPath();ctx.arc(n.x,n.y,NODE_RADIUS,0,2*Math.PI);
                ctx.fillStyle=cS?(iAP?cS.a:cS.p):'#ff00ff'; ctx.fill();
                ctx.strokeStyle=iAP?'#000':'#333'; ctx.lineWidth=iAP?2:1; ctx.stroke();
                const fT=fractionLabel(n.ratio[0],n.ratio[1]); let fS=10; const aW=NODE_RADIUS*1.8;
                ctx.font=`${fS}px "Helvetica Neue"`; let tW=ctx.measureText(fT).width;
                while(tW>aW&&fS>4){fS--; ctx.font=`${fS}px "Helvetica Neue"`; tW=ctx.measureText(fT).width;}
                ctx.fillStyle='white'; ctx.textAlign='center'; ctx.textBaseline='middle'; ctx.fillText(fT,n.x,n.y);
                
                // Octave Selectors
                OCTAVE_MULTIPLIERS.forEach((multiplier, idx) => {
                    const y = n.y - (2 * OCTAVE_SELECTOR_Y_STEP) + (idx * OCTAVE_SELECTOR_Y_STEP);
                    const x = n.x + OCTAVE_SELECTOR_X_OFFSET;
                    ctx.beginPath();
                    ctx.arc(x, y, OCTAVE_SELECTOR_RADIUS, 0, 2 * Math.PI);
                    ctx.fillStyle = n.octaveStates[idx] ? '#000' : '#b3b3b3';
                    ctx.strokeStyle = '#999';
                    ctx.lineWidth = 1;
                    ctx.fill();
                    ctx.stroke();

                    if (hoveredOctave.node === n && hoveredOctave.octaveIndex === idx) {
                        const [nodeNum, nodeDen] = n.ratio;
                        const [multNum, multDen] = OCTAVE_MULTIPLIER_FRACS[idx];
                        const [simpNum, simpDen] = simplifyFraction(nodeNum * multNum, nodeDen * multDen);
                        const fracText = `${simpNum}/${simpDen}`;
                        
                        let hoverText = '';
                        if (displayMode === 'hz') {
                            const freq = fundamental * (nodeNum / nodeDen) * multiplier;
                            hoverText = `${fracText} (${freq.toFixed(1)} Hz)`;
                        } else {
                            hoverText = fracText;
                        }

                        ctx.fillStyle = '#555';
                        ctx.font = '8px "Helvetica Neue"';
                        ctx.textAlign = 'left';
                        ctx.textBaseline = 'middle';
                        ctx.fillText(hoverText, x + 5, y);
                    }
                });

                ctx.fillStyle = '#333';
                ctx.textAlign = 'center';
                ctx.font = '9px "Helvetica Neue"';
                let labelText;
                if (hoveredNode === n) {
                    if (fT === '1/1') {
                        labelText = 'Primes = 1';
                    } else {
                        const factors = [...new Set(n.non2Primes_withMultiplicity)].sort((a, b) => a - b);
                        labelText = 'Primes = ' + (factors.length > 0 ? factors.join(', ') : 'None');
                    }
                } else {
                    const baseFreq = fundamental * (n.ratio[0] / n.ratio[1]);
                    labelText = displayMode === 'hz' ? `${baseFreq.toFixed(1)}Hz` : freqToPitchClass(baseFreq);
                }
                ctx.fillText(labelText, n.x, n.y + LABEL_Y_OFFSET);
            }

            // Highlight Intervals (Red Links)
            if (highlightedIntervals.length > 0) {
                ctx.save();
                ctx.strokeStyle = 'red';
                ctx.lineWidth = 3;
                ctx.globalAlpha = 0.85;
                highlightedIntervals.forEach(pair => {
                    const [nodeA, nodeB] = pair;
                    const ax = nodeA.x, ay = nodeA.y;
                    const bx = nodeB.x, by = nodeB.y;

                    const HIGHLIGHT_CIRCLE_RADIUS = NODE_RADIUS + 3;
                    const vecX = bx - ax;
                    const vecY = by - ay;
                    const dist = Math.sqrt(vecX * vecX + vecY * vecY);

                    if (dist === 0) return;

                    const unitX = vecX / dist;
                    const unitY = vecY / dist;

                    const startX = ax + unitX * HIGHLIGHT_CIRCLE_RADIUS;
                    const startY = ay + unitY * HIGHLIGHT_CIRCLE_RADIUS;
                    const endX = bx - unitX * HIGHLIGHT_CIRCLE_RADIUS;
                    const endY = by - unitY * HIGHLIGHT_CIRCLE_RADIUS;
                    
                    if (dist > 2 * HIGHLIGHT_CIRCLE_RADIUS) {
                        ctx.beginPath();
                        ctx.moveTo(startX, startY);
                        ctx.lineTo(endX, endY);
                        ctx.stroke();
                    }

                    ctx.beginPath();
                    ctx.arc(ax, ay, HIGHLIGHT_CIRCLE_RADIUS, 0, 2 * Math.PI);
                    ctx.stroke();

                    ctx.beginPath();
                    ctx.arc(bx, by, HIGHLIGHT_CIRCLE_RADIUS, 0, 2 * Math.PI);
                    ctx.stroke();
                });
                ctx.restore(); 
            }

            ctx.restore();
        });
    }

    /* --- AUDIO & STATE LOGIC --- */
    function deactivateOctave(nD, oI) {
        if (nD && nD.octaveStates && nD.octaveStates[oI]) {
            const { source, env } = nD.octaveStates[oI];
            const now = audioCtx.currentTime;
            env.gain.cancelScheduledValues(now);
            env.gain.setValueAtTime(env.gain.value, now);
            env.gain.linearRampToValueAtTime(0, now + releaseTime);
            source.stop(now + releaseTime + 0.1);
            nD.octaveStates[oI] = null;
        }
    }
    
    function toggleOctave(nD, oI, isMainNodeClick = false) {
        if (!nD) return;
        const octaveIndex = oI;

        if (nD.octaveStates[octaveIndex] !== null) {
            if (isMainNodeClick) {
                deactivateAllOctaves(nD);
            } else {
                deactivateOctave(nD, octaveIndex);
                drawLattice(); 
            }
            return;
        }
        
        const now = audioCtx.currentTime;
        const baseFreq = fundamental * (nD.ratio[0] / nD.ratio[1]);
        const targetFreq = baseFreq * OCTAVE_MULTIPLIERS[octaveIndex];
        const env = audioCtx.createGain();
        env.connect(lowPassFilter);
        env.gain.setValueAtTime(0, now);
        env.gain.linearRampToValueAtTime(1, now + attackTime);
        const source = audioCtx.createOscillator();
        source.type = waveform;
        source.frequency.setValueAtTime(targetFreq, now);
        source.connect(env);
        source.start(now);
        nD.octaveStates[octaveIndex] = { source, env };
        drawLattice();
    }
    
    function deactivateAllOctaves(nD){if(!nD)return;let ch=false;nD.octaveStates.forEach((o,i)=>{if(o!==null){deactivateOctave(nD,i);ch=true;}});if(ch)drawLattice();}
    window.deactivateAll=function(){nodes.forEach(f=>deactivateAllOctaves(f));}

    /* --- EVENT HANDLERS --- */
    function populateIntervalSelector() {
        const select = document.getElementById('interval-select');
        select.innerHTML = '<option value="">Select a preset...</option>';
        for (const groupName in PRESET_INTERVALS) {
            const optgroup = document.createElement('optgroup');
            optgroup.label = groupName;
            for (const intervalName in PRESET_INTERVALS[groupName]) {
                const option = document.createElement('option');
                option.textContent = intervalName;
                option.value = PRESET_INTERVALS[groupName][intervalName];
                optgroup.appendChild(option);
            }
            select.appendChild(optgroup);
        }
    }

    function resizeCanvas(){const c=document.getElementById('container');const dpr=window.devicePixelRatio||1;const r=c.getBoundingClientRect();canvas.width=r.width*dpr;canvas.height=r.height*dpr;canvas.style.width=`${r.width}px`;canvas.style.height=`${r.height}px`;drawLattice();}
    function getMouseWorldPos(e){const r=canvas.getBoundingClientRect();const mX=e.clientX-r.left;const mY=e.clientY-r.top;const wX=(mX-r.width/2-pan.x)/zoomLevel+centerX;const wY=(mY-r.height/2-pan.y)/zoomLevel+centerY;return{worldX:wX,worldY:wY};}
    
    canvas.addEventListener('mousemove', (e) => {
        const { worldX, worldY } = getMouseWorldPos(e);
        let newHoveredNode = null;
        let newHoveredOctave = { node: null, octaveIndex: -1 };
        let isHovering = false;
        
        const visibleNodes = nodes.filter(shouldNodeBeVisible);

        for (let i = visibleNodes.length - 1; i >= 0; i--) {
            const n = visibleNodes[i];
            
            for (let j = 0; j < OCTAVE_MULTIPLIERS.length; j++) {
                const sX = n.x + OCTAVE_SELECTOR_X_OFFSET;
                const sY = n.y - (2 * OCTAVE_SELECTOR_Y_STEP) + (j * OCTAVE_SELECTOR_Y_STEP);
                if (Math.pow(worldX - sX, 2) + Math.pow(worldY - sY, 2) < (OCTAVE_SELECTOR_RADIUS + 4) * (OCTAVE_SELECTOR_RADIUS + 4)) {
                    newHoveredOctave = { node: n, octaveIndex: j };
                    isHovering = true;
                    break;
                }
            }
            if (isHovering) break;

            if (Math.pow(worldX - n.x, 2) + Math.pow(worldY - n.y, 2) < NODE_RADIUS * NODE_RADIUS) {
                newHoveredNode = n;
                isHovering = true;
                break;
            }
        }

        canvas.style.cursor = isHovering ? 'pointer' : 'default';

        if (hoveredNode !== newHoveredNode || hoveredOctave.node !== newHoveredOctave.node || hoveredOctave.octaveIndex !== newHoveredOctave.octaveIndex) {
            hoveredNode = newHoveredNode;
            hoveredOctave = newHoveredOctave;
            drawLattice();
        }
    });

    canvas.addEventListener('click',(e)=>{const{worldX,worldY}=getMouseWorldPos(e);const vN=nodes.filter(shouldNodeBeVisible);const nTC=[...vN].reverse();
    for(const n of nTC){if(Math.pow(worldX-n.x,2)+Math.pow(worldY-n.y,2)<NODE_RADIUS*NODE_RADIUS){toggleOctave(n,2,true);return;}
    for(let j=0;j<OCTAVE_MULTIPLIERS.length;j++){const sX=n.x+OCTAVE_SELECTOR_X_OFFSET;const sY=n.y-(2*OCTAVE_SELECTOR_Y_STEP)+(j*OCTAVE_SELECTOR_Y_STEP);if(Math.pow(worldX-sX,2)+Math.pow(worldY-sY,2)<(OCTAVE_SELECTOR_RADIUS+4)*(OCTAVE_SELECTOR_RADIUS+4)){toggleOctave(n,j,false);return;}}}});
    
    // UPDATED: Wheel/Scroll event to handle Trackpad Pinch-to-Zoom
    canvas.addEventListener('wheel', (e) => {
        e.preventDefault();
        // If ctrlKey is pressed, it's a trackpad pinch (on most browsers)
        if (e.ctrlKey) {
            const zoomSensitivity = 0.005;
            const delta = -e.deltaY * zoomSensitivity;
            let newZoom = zoomLevel + delta;

            // Clamp zoom
            newZoom = Math.max(0.1, Math.min(3.0, newZoom));
            zoomLevel = newZoom;

            // Sync slider logic: zoomLevel = 0.5 * sliderVal + 0.2  =>  sliderVal = (zoomLevel - 0.2) / 0.5
            const sliderVal = (zoomLevel - 0.2) / 0.5;
            const slider = document.getElementById('zoom-slider');
            slider.value = sliderVal;
            document.getElementById('zoom-val').textContent = zoomLevel.toFixed(2);
        } else {
            // Normal panning
            pan.x -= e.deltaX;
            pan.y -= e.deltaY;
        }
        drawLattice();
    }, { passive: false });
    
    document.getElementById('zoom-slider').addEventListener('input',(e)=>{const dZ=parseFloat(e.target.value);zoomLevel=0.5*dZ+0.2;document.getElementById('zoom-val').textContent=dZ.toFixed(2);drawLattice();});
    document.getElementById('waveform').addEventListener('change',(e)=>{waveform=e.target.value;});
    document.getElementById('attack').addEventListener('input',(e)=>{attackTime=parseFloat(e.target.value);document.getElementById('attack-val').textContent=attackTime.toFixed(2);});
    document.getElementById('decay').addEventListener('input',(e)=>{releaseTime=parseFloat(e.target.value);document.getElementById('decay-val').textContent=releaseTime.toFixed(2);});
    document.getElementById('volume').addEventListener('input',(e)=>{const v=parseFloat(e.target.value);masterGain.gain.setValueAtTime(v,audioCtx.currentTime);document.getElementById('volume-val').textContent=v.toFixed(2);});
    document.getElementById('filter-freq').addEventListener('input',(e)=>{const v=parseFloat(e.target.value);lowPassFilter.frequency.setValueAtTime(v,audioCtx.currentTime);document.getElementById('filter-freq-val').textContent=v.toFixed(0);});
    document.getElementById('filter-q').addEventListener('input',(e)=>{const v=parseFloat(e.target.value);lowPassFilter.Q.setValueAtTime(v,audioCtx.currentTime);document.getElementById('filter-q-val').textContent=v.toFixed(1);});
    
    window.setFundamental=function(){
        const i=document.getElementById('fundamental-input').value.trim();
        let nF=0;
        if(displayMode==='hz'){
            nF=parseFloat(i);
        } else {
            nF=pitchNameToFreq(i);
        }
        
        if(nF>0){
            fundamental=nF;
            if(displayMode==='pitch'){
                document.getElementById('fundamental-input').value=freqToAbsolutePitchName(fundamental);
            } else { 
                document.getElementById('fundamental-input').value=fundamental.toFixed(2);
            }
            deactivateAll();
            highlightedPitchClasses = []; 
            drawLattice();
        }
        else{
            alert(`Invalid format for ${displayMode==='hz'?'Frequency (Hz)':'Pitch Name (+ Cents)'}. Example: 440 or A4 +0c.`);
            if(displayMode==='hz'){
                document.getElementById('fundamental-input').value=fundamental.toFixed(2);
            } else {
                document.getElementById('fundamental-input').value=freqToAbsolutePitchName(fundamental);
            }
        }
    };

    document.querySelectorAll('input[name="pitch-display"]').forEach(r=>{r.addEventListener('change',(e)=>{displayMode=e.target.value;const iE=document.getElementById('fundamental-input');const lE=document.getElementById('fundamental-label');
    if(displayMode==='hz'){lE.textContent='Fundamental (Hz):';iE.value=fundamental.toFixed(2);}else{lE.textContent='Fundamental (Pitch + Cents):';iE.value=freqToAbsolutePitchName(fundamental);}drawLattice();});});
    
    const pLS=document.getElementById('prime-limit-select');const pCB=document.querySelectorAll('#prime-filters input[type="checkbox"]');
    const pL={'3':[3],'5':[3,5],'7':[3,5,7],'11':[3,5,7,11],'13':[3,5,7,11,13],'17':[3,5,7,11,13,17],'19':[3,5,7,11,13,17,19],'23':[3,5,7,11,13,17,19,23],'29':[3,5,7,11,13,17,19,23,29],'31':[3,5,7,11,13,17,19,23,29,31]};
    function updateFiltersFromDropdown(){const l=pLS.value;if(l==='custom')return;const pTS=new Set(pL[l]);activePrimes.clear();pCB.forEach(cb=>{const p=parseInt(cb.dataset.prime);cb.checked=pTS.has(p);if(cb.checked)activePrimes.add(p);});drawLattice();}
    pLS.addEventListener('change',updateFiltersFromDropdown);
    pCB.forEach(cb=>{cb.addEventListener('change',(e)=>{const p=parseInt(e.target.dataset.prime);if(e.target.checked){activePrimes.add(p);}else{activePrimes.delete(p);}pLS.value='custom';drawLattice();});});

    document.getElementById('parent-limit-select').addEventListener('change', (e) => {
        const newMode = e.target.value;
        const activeNodesToPreserve = nodes.filter(n => n.octaveStates.some(osc => osc !== null));
        const newData = generateLatticeNodes(newMode, activeNodesToPreserve);
        nodes = newData.nodes;
        existingRatios = newData.existingRatios;
        drawLattice();
    });

    document.getElementById('show-harmonics').addEventListener('change', (e) => {
        showHarmonics = e.target.checked;
        drawLattice();
    });
    document.getElementById('show-subharmonics').addEventListener('change', (e) => {
        showSubharmonics = e.target.checked;
        drawLattice();
    });

    document.getElementById('interval-select').addEventListener('change', (e) => {
        const ratioString = e.target.value;
        const num1Input = document.getElementById('interval-num1');
        const num2Input = document.getElementById('interval-num2');
        if (ratioString) {
            const [numStr, denStr] = ratioString.split('/');
            num1Input.value = numStr;
            num2Input.value = denStr;
        } else {
            num1Input.value = '';
            num2Input.value = '';
        }
    });
    document.getElementById('interval-num1').addEventListener('input', () => { document.getElementById('interval-select').value = ''; });
    document.getElementById('interval-num2').addEventListener('input', () => { document.getElementById('interval-select').value = ''; });

    document.getElementById('locate-interval-btn').addEventListener('click', () => {
        const num1 = parseInt(document.getElementById('interval-num1').value);
        const num2 = parseInt(document.getElementById('interval-num2').value);
        if (isNaN(num1) || isNaN(num2) || num1 <= 0 || num2 <= 0) {
            alert('Please enter valid positive integers for the ratio.');
            highlightedIntervals = [];
            drawLattice();
            return;
        }
        const targetInterval = normalizeIntervalRatio(num1, num2); 
        highlightedIntervals = [];
        const visibleNodes = nodes.filter(shouldNodeBeVisible);
        for (let i = 0; i < visibleNodes.length; i++) {
            for (let j = i + 1; j < visibleNodes.length; j++) {
                const nodeA = visibleNodes[i];
                const nodeB = visibleNodes[j];
                const intervalNum = nodeA.ratio[0] * nodeB.ratio[1];
                const intervalDen = nodeA.ratio[1] * nodeB.ratio[0];
                const nodeInterval = normalizeIntervalRatio(intervalNum, intervalDen);
                if (nodeInterval[0] === targetInterval[0] && nodeInterval[1] === targetInterval[1]) {
                    highlightedIntervals.push([nodeA, nodeB]);
                }
            }
        }
        drawLattice();
    });

    document.getElementById('clear-interval-btn').addEventListener('click', () => {
        highlightedIntervals = [];
        document.getElementById('interval-select').value = '';
        document.getElementById('interval-num1').value = '';
        document.getElementById('interval-num2').value = '';
        drawLattice();
    });

    document.getElementById('locate-pitch-btn').addEventListener('click', () => {
        const minValStr = document.getElementById('pitch-range-min').value.trim();
        const maxValStr = document.getElementById('pitch-range-max').value.trim();

        const minCents = parsePitchClassToCents(minValStr);
        const maxCents = parsePitchClassToCents(maxValStr);

        if (minCents === null || maxCents === null) {
            alert('Invalid Pitch format. Please use "Note +Cents" (e.g., "C", "F# +10c", "Bb -5c").');
            return;
        }

        highlightedPitchClasses = [];
        const visibleNodes = nodes.filter(shouldNodeBeVisible);

        visibleNodes.forEach(node => {
            const baseFreq = fundamental * (node.ratio[0] / node.ratio[1]);
            const nodeCents = freqToAbsoluteCents(baseFreq);

            let isMatch = false;
            if (minCents <= maxCents) {
                if (nodeCents >= minCents && nodeCents <= maxCents) isMatch = true;
            } else {
                if (nodeCents >= minCents || nodeCents <= maxCents) isMatch = true;
            }

            if (isMatch) highlightedPitchClasses.push(node);
        });

        drawLattice();
    });

    document.getElementById('clear-pitch-btn').addEventListener('click', () => {
        highlightedPitchClasses = [];
        document.getElementById('pitch-range-min').value = '';
        document.getElementById('pitch-range-max').value = '';
        drawLattice();
    });
    
    document.querySelectorAll('.control-group > h2').forEach(header => {
        header.addEventListener('click', () => {
            header.parentElement.classList.toggle('collapsed');
        });
    });

    window.addEventListener('resize', resizeCanvas); 
    const initialData = generateLatticeNodes(document.getElementById('parent-limit-select').value);
    nodes = initialData.nodes;
    existingRatios = initialData.existingRatios;
    populateIntervalSelector();
    resizeCanvas();

  </script>
</body>
</html>
