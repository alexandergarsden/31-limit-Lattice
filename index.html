<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <title>Just intonation pitch lattice (Primes up to 31)</title>
  <style>
    /* ------------------- BASE & LAYOUT ------------------- */
    body { 
        font-family: 'Helvetica Neue', Helvetica, Arial, sans-serif; 
        background: #f4f7f9; 
        color: #333; 
        position: relative; 
        margin: 0;
        padding-top: 80px; 
        padding-right: 300px; 
        overflow: hidden;
    }
    
    #header {
        position: fixed; 
        top: 0;
        left: 0;
        right: 300px; 
        background: #ffffff;
        padding: 10px 20px;
        border-bottom: 1px solid #ddd;
        box-shadow: 0 2px 4px rgba(0,0,0,0.05); 
        z-index: 1000;
        box-sizing: border-box; 
    }

    #container { 
        height: calc(100vh - 80px);
        overflow: hidden;
        position: relative;
    }

    canvas {
        position: absolute;
        top: 0;
        left: 0;
        background: #fff;
    }
    
    /* FONT WEIGHT STYLES (BOLD) */
    h1 { font-size: 1.5em; margin: 0; font-weight: 700; }
    h2 { 
        font-size: 1.1em; 
        margin-top: 0; 
        margin-bottom: 6px; /* Compact */
        color: #1e601e; 
        font-weight: 700; 
    }
    button { 
        font-weight: 700; 
        margin-top: 8px; /* Compact */
    }

    /* FONT WEIGHT STYLES (LIGHT) */
    #header p { margin: 5px 0 0 0; font-size: 0.87em; color: #555; font-weight: 300; } /* Compact */
    .control-group p { font-weight: 300; font-size: 0.87em; margin: 4px 0 6px 0; } /* Compact */
    label { 
        display: block; 
        margin-top: 6px; /* Compact */
        font-size: 0.87em; 
        font-weight: 300; 
        color: #444;
    }
    label span { font-weight: 300; }
    select, input[type="text"] { font-weight: 300; }
    
    .checkbox-group {
        display: flex;
        flex-wrap: wrap; 
        gap: 8px 12px; /* Compact */
    }
    .checkbox-group label { 
        display: flex;
        align-items: center;
        margin-top: 0;
        font-weight: 300; 
        cursor: pointer;
    }
    .checkbox-group input[type="radio"],
    .checkbox-group input[type="checkbox"] {
        margin-right: 5px;
    }

    /* ------------------- CONTROL PANEL STYLING ------------------- */
    #control-panel { 
        position: fixed; 
        top: 0;
        right: 0;
        width: 300px; 
        padding: 20px; 
        background: #ffffff;
        height: 100vh; 
        overflow-y: auto; 
        box-shadow: -2px 0 8px rgba(0,0,0,0.1); 
        z-index: 100;
        box-sizing: border-box;
    }

    .control-group { 
        margin-bottom: 12px; /* Compact */
        padding-bottom: 12px; /* Compact */
        border-bottom: 1px solid #eee;
    }
    .control-group:last-child { border-bottom: none; padding-bottom: 0; }
    
    input[type="range"] { 
        width: 100%; 
        margin: 4px 0; /* Compact */
        -webkit-appearance: none; appearance: none;
        height: 4px; background: #ddd; border-radius: 2px;
    }
    
    .display-nodes-container {
        display: flex;
        gap: 20px;
    }
    .display-nodes-container > div:first-child { flex: 1.2; }
    .display-nodes-container > div:last-child { flex: 1; }
    
    #prime-filters-container .grid-label {
        margin-top: 0;
    }
    .prime-checkbox-grid {
        display: grid;
        grid-template-columns: 1fr 1fr;
        gap: 4px 10px;
        margin-top: 5px;
    }
    .prime-checkbox-grid label {
        margin-top: 0;
        display: flex;
        align-items: center;
    }
    select#prime-limit-select, select#parent-limit-select, #waveform {
        width: 100%;
        margin-top: 5px;
    }

    /* ------------------- ACCORDION FOR CONTROL PANEL ------------------- */
    .control-group > h2 {
        cursor: pointer;
        user-select: none;
        position: relative;
        padding-right: 1.5em; /* Space for arrow */
    }
    .control-group > h2::after {
        content: '▾';
        position: absolute;
        right: 0;
        top: 50%;
        transform: translateY(-50%);
        font-size: 0.9em;
        color: #888;
    }
    .control-group.collapsed > h2::after {
        content: '▸';
    }
    .control-group.collapsed > .control-content {
        display: none;
    }

  </style>
</head>
<body>
  
  <div id="header">
    <h1>Just intonation pitch lattice (Primes up to 31)</h1>
    <p>Click a node (or the octave selectors to the right of each node) to play pitches. All nodes default to within one octave above the fundamental. Use the control panel to control the sound, how pitches are displayed, which primes are displayed, and to locate specific intervals. Copyright © Alexander Garsden 2025.</p>
  </div>

  <div id="container">
    <canvas id="lattice"></canvas>
  </div>

  <div id="control-panel">
    
    <div class="control-group">
        <h2>Lattice View</h2>
        <div class="control-content">
            <label for="zoom-slider">Zoom Level: <span id="zoom-val">1.00</span>x</label>
            <input type="range" id="zoom-slider" min="0.1" max="2.6" step="0.05" value="1.0">
        </div>
    </div>

    <div class="control-group">
        <h2>Sound Controls</h2>
        <div class="control-content">
            <div id="top-sound-row" style="display: flex; gap: 15px; align-items: flex-end; margin-bottom: 6px;">
                <div style="flex: 1.2;">
                    <label for="waveform" style="margin-top:0;">Waveform:</label>
                    <select id="waveform">
                        <option value="sine" selected>Sine</option>
                        <option value="square">Square</option>
                        <option value="triangle">Triangle</option>
                        <option value="sawtooth">Sawtooth</option>
                    </select>
                </div>
                <div style="flex: 1;">
                    <label for="volume" style="margin-top:0;">Gain: <span id="volume-val">0.05</span></label>
                    <input type="range" id="volume" min="0" max="0.5" step="0.01" value="0.05">
                </div>
            </div>
            <div id="slider-grid" style="display: grid; grid-template-columns: 1fr 1fr; gap: 0 15px;">
                <div>
                    <label for="attack">Attack: <span id="attack-val">0.50</span>s</label>
                    <input type="range" id="attack" min="0.01" max="2.0" step="0.01" value="0.50">
                    <label for="decay">Release: <span id="decay-val">1.00</span>s</label>
                    <input type="range" id="decay" min="0.01" max="4.0" step="0.01" value="1.00">
                </div>
                <div>
                    <label for="filter-freq">LPF (Hz): <span id="filter-freq-val">5000</span></label>
                    <input type="range" id="filter-freq" min="100" max="20000" step="10" value="5000">
                    <label for="filter-q">Resonance (Q): <span id="filter-q-val">1.0</span></label>
                    <input type="range" id="filter-q" min="0.1" max="20" step="0.1" value="1.0">
                </div>
            </div>
            <button onclick="deactivateAll()" style="width: 100%;">Stop All Sound</button>
        </div>
    </div>
    
    <div class="control-group">
        <h2>Pitch Display & Fundamental</h2>
        <div class="control-content">
            <label>Pitch Display:</label>
            <div class="checkbox-group">
                <label><input type="radio" name="pitch-display" value="hz" id="display-hz" checked> Hz</label>
                <label><input type="radio" name="pitch-display" value="pitch" id="display-pitch"> Pitch Name (+ Cents)</label>
            </div>
            <label for="fundamental-input" id="fundamental-label">Fundamental (Hz):</label>
            <input type="text" id="fundamental-input" value="440" onchange="setFundamental()">
            <p>*Pitch example: A4 +0c</p>
        </div>
    </div>

    <div class="control-group">
        <h2>Displayed Nodes</h2>
        <div class="control-content">
            <div class="display-nodes-container">
                <div>
                    <label for="prime-limit-select" style="margin-top:0;">Prime Limit:</label>
                    <select id="prime-limit-select">
                        <option value="custom">Custom</option>
                        <option value="3">3-limit</option>
                        <option value="5">5-limit</option>
                        <option value="7" selected>7-limit</option>
                        <option value="11">11-limit</option>
                        <option value="13">13-limit</option>
                        <option value="17">17-limit</option>
                        <option value="19">19-limit</option>
                        <option value="23">23-limit</option>
                        <option value="29">29-limit</option>
                        <option value="31">31-limit</option>
                    </select>

                    <label for="parent-limit-select">Generate primes >5 from:</label>
                    <select id="parent-limit-select">
                        <option value="5-limit" selected>5-limit</option>
                        <option value="all">Primes >5</option>
                    </select>
                </div>
                <div id="prime-filters-container">
                    <label class="grid-label" style="margin-top:0;">Individual Primes:</label>
                    <div id="prime-filters" class="prime-checkbox-grid">
                        <label><input type="checkbox" data-prime="3" checked> 3</label>
                        <label><input type="checkbox" data-prime="11"> 11</label>
                        <label><input type="checkbox" data-prime="5" checked> 5</label>
                        <label><input type="checkbox" data-prime="13"> 13</label>
                        <label><input type="checkbox" data-prime="7" checked> 7</label>
                        <label><input type="checkbox" data-prime="17"> 17</label>
                        <label><input type="checkbox" data-prime="19"> 19</label>
                        <label><input type="checkbox" data-prime="23"> 23</label>
                        <label><input type="checkbox" data-prime="29"> 29</label>
                        <label><input type="checkbox" data-prime="31"> 31</label>
                    </div>
                </div>
            </div>
            <div class="checkbox-group" style="margin-top: 12px;">
                <label><input type="checkbox" id="show-harmonics" checked> Harmonics</label>
                <label><input type="checkbox" id="show-subharmonics" checked> Subharmonics</label>
            </div>
        </div>
    </div>

    <div class="control-group">
        <h2>Locate Interval</h2>
        <div class="control-content">
            <p>Find pairs of nodes matching an interval. Use a preset or enter a ratio manually.</p>
            <div id="locate-interval-container" style="display: flex; flex-direction: column; gap: 6px; margin-top: 5px;">
                <label for="interval-select" style="margin-top:0; margin-bottom:-4px;">Presets:</label>
                <select id="interval-select" style="width: 100%;"></select>
                
                <label for="interval-num1" style="margin-top:6px; margin-bottom:-4px;">Manual Ratio:</label>
                <div id="manual-interval-inputs" style="display: flex; align-items: center; gap: 5px;">
                    <input type="text" id="interval-num1" placeholder="e.g. 3" style="text-align: center; font-weight: 300; width: 100%;">
                    <span style="font-weight: bold; color: #555;">:</span>
                    <input type="text" id="interval-num2" placeholder="e.g. 2" style="text-align: center; font-weight: 300; width: 100%;">
                </div>
                
                <div style="display: flex; gap: 10px; margin-top: 2px;">
                    <button id="locate-interval-btn" style="flex: 1; margin-top: 0;">Find</button>
                    <button id="clear-interval-btn" style="flex: 1; margin-top: 0;">Clear</button>
                </div>
            </div>
        </div>
    </div>

  </div>

  <script>
    /* 1. GLOBAL STATE & AUDIO SETUP */
    const AudioContext = window.AudioContext || window.webkitAudioContext;
    const audioCtx = new AudioContext();
    const masterGain = audioCtx.createGain();
    masterGain.gain.value = 0.05; 
    const lowPassFilter = audioCtx.createBiquadFilter();
    lowPassFilter.type = 'lowpass';
    lowPassFilter.frequency.setValueAtTime(5000, audioCtx.currentTime); 
    lowPassFilter.Q.setValueAtTime(1.0, audioCtx.currentTime); 
    lowPassFilter.connect(masterGain);
    masterGain.connect(audioCtx.destination);
    
    let fundamental = 440;
    let waveform = 'sine';
    let attackTime = 0.5;
    let releaseTime = 1.0;
    const activePrimes = new Set([3, 5, 7]); 
    let displayMode = 'hz'; 
    
    // --- START OF ZOOM LOGIC CHANGE ---
    const BASE_INTERNAL_ZOOM = 0.7; // The base internal zoom level (where UI shows 1.0x)
    let uiZoomFactor = 1.0;         // The value displayed/controlled by the slider
    let zoomLevel = BASE_INTERNAL_ZOOM; // The actual canvas zoom level
    // --- END OF ZOOM LOGIC CHANGE ---

    let pan = { x: 0, y: 0 };
    let showHarmonics = true;
    let showSubharmonics = true;
    
    let hoveredNode = null;
    let hoveredOctave = { node: null, octaveIndex: -1 };
    let highlightedIntervals = [];

    // State variables for panning interaction
    let isDragging = false;
    let lastMouseX, lastMouseY;

    /* 2. UTILITY FUNCTIONS */
    function gcd(a,b){ return b===0?a:gcd(b,a%b); }
    function simplifyFraction(n,d){ const g=gcd(Math.round(n),Math.round(d)); return [Math.round(n)/g,Math.round(d)/g]; }
    function normalizeOctave(n, d){ let num = Math.round(n); let den = Math.round(d); while(num / den >= 2) den *= 2; while(num / den < 1) num *= 2; return [num, den]; }
    function fractionLabel(n,d){ const [num,den]=simplifyFraction(n,d); return `${num}/${den}`; }
    function primeFactors(n){ const f=[]; let num=n; let d=2; while(num>1 && d<=num){ if(num%d===0){ f.push(d); num/=d; } else d++; } return f; }
    function ratioPrimeFactors([n,d]){ const nF=primeFactors(n); const dF=primeFactors(d); return [...new Set([...nF,...dF])].sort((a,b)=>a-b); }
    function getRatioPrimeFactorsWithMultiplicity([n, d]) { return [...primeFactors(n), ...primeFactors(d)].filter(p => p > 2); }
    const PITCH_NAMES = ["C", "C#", "D", "D#", "E", "F", "F#", "G", "G#", "A", "A#", "B"];
    const C4_FREQ = 440 * Math.pow(2, -9/12); 
    function freqToPitchName(freq) {
        if (freq <= 0) return "0 Hz"; const r=freq/C4_FREQ; const tS=12*Math.log2(r); const nS=Math.round(tS);
        const pI=(nS % 12 + 12)%12; const o=4+Math.floor(nS/12); const eF=C4_FREQ*Math.pow(2,nS/12);
        const c=1200*Math.log2(freq/eF); const pN=PITCH_NAMES[pI]+o; const cS=c.toFixed(0);
        return `${pN} ${cS>=0?'+':''}${cS}c`;
    }
    function pitchNameToFreq(pS) {
        const m=pS.match(/([A-G]#?)([0-9])\s*([+\-]\d+)c?/i); if(!m)return null; const[,n,oS,cS]=m;
        const o=parseInt(oS); const c=parseInt(cS); let pI=PITCH_NAMES.indexOf(n.toUpperCase()); if(pI===-1)return null;
        const tI=(o*12)+pI-48; const eF=C4_FREQ*Math.pow(2,tI/12); return eF*Math.pow(2,c/1200);
    }
    function shouldNodeBeVisible(node) {
        if (fractionLabel(node.ratio[0], node.ratio[1]) === '1/1') return true;
        if (node.octaveStates.some(o => o !== null)) return true;

        // Filter by harmonics/subharmonics
        const numPrimes = primeFactors(node.ratio[0]).filter(p => p !== 2);
        const denPrimes = primeFactors(node.ratio[1]).filter(p => p !== 2);
        
        if (!showSubharmonics && numPrimes.length > 0) return false; // Hide nodes from multiplying primes
        if (!showHarmonics && denPrimes.length > 0) return false;  // Hide nodes from dividing primes

        // Filter by generation mode (parent limit)
        const generationMode = document.getElementById('parent-limit-select').value;
        if (generationMode === '5-limit') {
            const highPrimesCount = node.non2Primes_withMultiplicity.filter(p => p > 5).length;
            if (highPrimesCount > 1) return false;
        }

        // Filter by individual prime checkboxes
        const uniqueNon2Primes = node.primes.filter(p => p > 2);
        return uniqueNon2Primes.every(p => activePrimes.has(p));
    }
    function getMaxPrime(node) { return node.primes.filter(p => p > 2).reduce((max, p) => Math.max(max, p), 1); }
    function getHighestPrimeLimit(node) {
        if (fractionLabel(node.ratio[0],node.ratio[1])==='1/1') return 1; const mP=node.primes.filter(p=>p>2).reduce((m,p)=>Math.max(m,p),3);
        if(mP>=31)return 31; if(mP>=29)return 29; if(mP>=23)return 23; if(mP>=19)return 19; if(mP>=17)return 17;
        if(mP>=13)return 13; if(mP>=11)return 11; if(mP>=7)return 7; if(mP>=5)return 5; return 3; 
    }
    function isFactorRelated(a,b,factor){
     const eps=1e-6; const r=(a.ratio[0]/a.ratio[1])/(b.ratio[0]/b.ratio[1]); 
     const k1=Math.round(Math.log2(factor/r)); if(Math.abs(r*Math.pow(2,k1)-factor)<eps) return true;
     const k2=Math.round(Math.log2((1/factor)/r)); if(Math.abs(r*Math.pow(2,k2)-(1/factor))<eps) return true;
     return false;
    }
    function normalizeIntervalRatio(n, d) {
        if (n === 0 || d === 0) return [0, 0];
        let num = Math.abs(n);
        let den = Math.abs(d);
        while (num > 0 && num % 2 === 0) num /= 2;
        while (den > 0 && den % 2 === 0) den /= 2;
        const commonDivisor = gcd(num, den);
        num /= commonDivisor;
        den /= commonDivisor;
        return num < den ? [num, den] : [den, num];
    }


    /* 3. LATTICE PARAMETERS & DATA */
    const latticeRange = { x: [-4, 4], y: [-2, 2] }; 
    const canvas = document.getElementById("lattice"); const ctx = canvas.getContext("2d");
    const WORLD_WIDTH = 4000; const WORLD_HEIGHT = 2600; 
    const spacing = 480; const centerX = WORLD_WIDTH / 2; const centerY = WORLD_HEIGHT / 2;
    const NODE_RADIUS = 20 * (2 / 3); const LABEL_Y_OFFSET = 25;
    const OCTAVE_MULTIPLIERS = [4, 2, 1, 0.5, 0.25];
    const OCTAVE_MULTIPLIER_FRACS = [[4, 1], [2, 1], [1, 1], [1, 2], [1, 4]];
    const OCTAVE_SELECTOR_X_OFFSET = 24; const OCTAVE_SELECTOR_Y_STEP = 10 * (2 / 3); const OCTAVE_SELECTOR_RADIUS = 2;
    
    const P_VECTORS = (() => {
        const rad = (deg) => deg * Math.PI / 180;
        const vectors = {
            7:  { r: 0.64, a: 20 }, 11: { r: 0.64, a: 70 },
            13: { r: 0.70, a: 40 }, 17: { r: 0.17, a: 50 },
            19: { r: 0.33, a: 30 }, 23: { r: 0.33, a: 60 },
            29: { r: 0.25, a: 10 }, 31: { r: 0.25, a: 80 }
        };
        
        const finalVectors = { 3: { x: 1, y: 0 }, 5: { x: 0, y: 1 } };
        for(const p in vectors) {
            const { r, a } = vectors[p];
            finalVectors[p] = { x: r * Math.cos(rad(a)), y: r * Math.sin(rad(a)) };
        }
        return finalVectors;
    })();

    const PRESET_INTERVALS = {
        "Pythagorean/3-Limit": {
            "Perfect 5ths (3:2) & 4ths (4:3)": "3/2",
        },
        "5-Limit (Ptolemaic)": {
            "Major 3rds (5:4) & minor 6ths (8:5)": "5/4",
            "Minor 3rds (6:5) & major 6ths (5:3)": "6/5",
            "Major Limma (135:128)": "135/128",
            "Just Chromatic Semitone (25:24)": "25/24",
            "Greater Diesis (648:625)": "648/625",
            "Lesser Diesis (128:125)": "128/125",
        },
        "7-Limit (Septimal)": {
            "Harmonic Seventh (7:4)": "7/4",
            "Septimal Tritone (7:5)": "7/5",
            "Septimal Minor Third (7:6)": "7/6",
            "Septimal Quartertone (36:35)": "36/35",
        },
        "11-Limit (Undecimal)": {
            "Undecimal Tritone (11:8)": "11/8",
            "Undecimal Supermajor Second (11:9)": "11/9",
            "Undecimal Quartertone (33:32)": "33/32",
        },
        "Commas & Micro-intervals": {
            "Septimal Diesis (49:48)": "49/48",
            "Septimal Comma (64:63)": "64/63",
            "Syntonic Comma (81:80)": "81/80",
            "Diaschisma (2048:2025)": "2048/2025",
            "Septimal Kleisma (225:224)": "225/224",
            "Breedsma (2401:2400)": "2401/2400",
            "Ragisma (4375:4374)": "4375/4374",
        }
    };

    /* 4. NODE GENERATION */
    let nodes;
    let existingRatios;
    let visibleNodesCache = []; // Cache for visible nodes

    function generateLatticeNodes(generationMode = 'all', nodesToPreserve = []) {
        const newNodes = []; const newRatios = new Map(); const ratioKey = r => r.join(',');
        // Preserving active state from old nodes
        const preservedStateMap = new Map();
        nodesToPreserve.forEach(node => {
            preservedStateMap.set(ratioKey(node.ratio), node.octaveStates);
        });

        const createNode = (ratio, x, y) => {
            const key = ratioKey(ratio); 
            // Check if node already exists (e.g., preserving state from previous call)
            if (newRatios.has(key)) {
                return newRatios.get(key);
            }

            const newNode = { 
                ratio, x, y, 
                primes: ratioPrimeFactors(ratio), 
                non2Primes_withMultiplicity: getRatioPrimeFactorsWithMultiplicity(ratio), 
                simplicityScore: ratio[0]*ratio[1], 
                // Restore state if available, otherwise initialize to inactive
                octaveStates: preservedStateMap.get(key) || new Array(5).fill(null) 
            };
            newNodes.push(newNode); 
            newRatios.set(key, newNode); 
            return newNode;
        };

        const baseGridSnapshot = [];
        for (let c3=latticeRange.x[0]; c3<=latticeRange.x[1]; c3++) {
            for (let c5=latticeRange.y[0]; c5<=latticeRange.y[1]; c5++) {
                const n3=c3>0?3**c3:1; const d3=c3<0?3**(-c3):1; const n5=c5>0?5**c5:1; const d5=c5<0?5**(-c5):1;
                const r=normalizeOctave(n3*n5,d3*d5);
                const x=centerX+(c3*P_VECTORS[3].x*spacing)+(c5*P_VECTORS[5].x*spacing);
                const y=centerY-((c3*P_VECTORS[3].y*spacing)+(c5*P_VECTORS[5].y*spacing));
                baseGridSnapshot.push(createNode(r,x,y));
            }
        }
        const expand = (base, prime) => {
            const v=P_VECTORS[prime]; const created=[];
            base.forEach(pN => {
                const uR=normalizeOctave(...simplifyFraction(pN.ratio[0]*prime,pN.ratio[1]));
                const uN=createNode(uR, pN.x+v.x*spacing, pN.y-v.y*spacing); if(uN)created.push(uN);
                const dR=normalizeOctave(...simplifyFraction(pN.ratio[0],pN.ratio[1]*prime));
                const dN=createNode(dR, pN.x-v.x*spacing, pN.y+v.y*spacing); if(dN)created.push(dN);
            });
            return created;
        };
        const hP=[7,11,13,17,19,23,29,31]; 
        if(generationMode==='5-limit'){hP.forEach(p=>{expand(baseGridSnapshot,p);});}
        else{ const fOS=[]; hP.forEach(p=>{fOS.push(...expand(baseGridSnapshot,p));}); hP.forEach(p=>{expand(fOS,p);}); }
        newNodes.sort((a,b)=>b.simplicityScore-a.simplicityScore);
        return {nodes:newNodes, existingRatios:newRatios};
    }

    /* 5. CANVAS DRAWING AND INTERACTION LOGIC */
    const NODE_COLORS = {
        1:{p:'#ccc',a:'#000'}, 3:{p:'#b3d6b3',a:'#1e601e'}, 5:{p:'#c3cde6',a:'#191970'},
        7:{p:'#e0b3e0',a:'#800080'}, 11:{p:'#ffb3b3',a:'#ff0000'}, 13:{p:'#e5c9b3',a:'#a0522d'},
        17:{p:'#b3e5e5',a:'#008080'}, 19:{p:'#a0d6b4', a: '#2E8B57' }, 23:{p:'#DAA520',a:'#b8860b'},
        29:{p:'#e5b3b3',a:'#b22222'}, 31:{p:'#b3cce5',a:'#0047ab'}
    };
    const LINE_COLORS = { dark: '#666', light: '#ddd' };
    
    function drawLattice() {
        requestAnimationFrame(() => {
            const dpr = window.devicePixelRatio || 1; const r = canvas.getBoundingClientRect();
            ctx.clearRect(0,0,r.width*dpr,r.height*dpr); ctx.save(); ctx.scale(dpr,dpr); 
            ctx.translate(r.width/2+pan.x, r.height/2+pan.y); ctx.scale(zoomLevel,zoomLevel); ctx.translate(-centerX,-centerY);
            const aP=[3,5,7,11,13,17,19,23,29,31]; const sMDS=spacing*1.2*spacing*1.2;
            
            // 1. Filter nodes to be visible
            const vN = nodes.filter(shouldNodeBeVisible);
            visibleNodesCache = vN; 

            // 2. Aggregate nodes by visual coordinates for de-duplication and state checks
            const nodesAtCoord = new Map(); // Key: "x,y", Value: Array of nodes (e.g., 1/1, 2/1, 4/1)
            const pM = new Map(); // Key: "x,y", Value: The single node chosen for rendering (last one in vN wins)

            for (const n of vN) {
                const pK = `${n.x.toFixed(3)},${n.y.toFixed(3)}`;
                if (!nodesAtCoord.has(pK)) {
                    nodesAtCoord.set(pK, []);
                }
                nodesAtCoord.get(pK).push(n);
                
                // Keep track of the node that will be visually rendered (last one wins)
                pM.set(pK, n);
            }

            const nTR = Array.from(pM.values()); // Nodes To Render (deduplicated list)
            
            // Draw lines
            for(let i=0;i<nTR.length;i++){
                for(let j=i+1;j<nTR.length;j++){
                    const f=nTR[i],g=nTR[j]; if(Math.pow(f.x-g.x,2)+Math.pow(f.y-g.y,2)>sMDS)continue;
                    for(const fac of aP){if(isFactorRelated(f,g,fac)){let c=LINE_COLORS.light;if(fac<=5&&getMaxPrime(f)<7&&getMaxPrime(g)<7){c=LINE_COLORS.dark;}
                    ctx.beginPath();ctx.strokeStyle=c;ctx.lineWidth=1;ctx.moveTo(f.x,f.y);ctx.lineTo(g.x,g.y);ctx.stroke();break;}}}}
            
            // Draw nodes and octave selectors
            for(const n of nTR){
                const pK = `${n.x.toFixed(3)},${n.y.toFixed(3)}`;
                const nodesAtThisCoord = nodesAtCoord.get(pK) || [];

                // Determine if ANY node at this visual location is active (Octave duplication fix)
                let isAnyActive = false;
                for (const dupeNode of nodesAtThisCoord) {
                    if (dupeNode.octaveStates.some(o => o !== null)) {
                        isAnyActive = true;
                        break;
                    }
                }
                
                const iAP = isAnyActive;
                const l=getHighestPrimeLimit(n); const cS=NODE_COLORS[l];
                
                let nodeFillColor = cS ? (iAP ? cS.a : cS.p) : '#ff00ff';
                
                ctx.beginPath();ctx.arc(n.x,n.y,NODE_RADIUS,0,2*Math.PI);
                ctx.fillStyle=nodeFillColor; ctx.fill();
                ctx.strokeStyle=iAP?'#000':'#333'; ctx.lineWidth=iAP?2:1; ctx.stroke();
                const fT=fractionLabel(n.ratio[0],n.ratio[1]); let fS=10; const aW=NODE_RADIUS*1.8;
                ctx.font=`${fS}px "Helvetica Neue"`; let tW=ctx.measureText(fT).width;
                while(tW>aW&&fS>4){fS--; ctx.font=`${fS}px "Helvetica Neue"`; tW=ctx.measureText(fT).width;}
                ctx.fillStyle='white'; ctx.textAlign='center'; ctx.textBaseline='middle'; ctx.fillText(fT,n.x,n.y);
                
                // Octave selectors (must check all nodes at this coordinate for the specific octave state)
                
                OCTAVE_MULTIPLIERS.forEach((multiplier, idx) => {
                    const y = n.y - (2 * OCTAVE_SELECTOR_Y_STEP) + (idx * OCTAVE_SELECTOR_Y_STEP);
                    const x = n.x + OCTAVE_SELECTOR_X_OFFSET;
                    ctx.beginPath();
                    ctx.arc(x, y, OCTAVE_SELECTOR_RADIUS, 0, 2 * Math.PI);
                    
                    // Determine if ANY node at this coordinate has THIS SPECIFIC octave active
                    let isThisOctaveActive = false;
                    for (const dupeNode of nodesAtThisCoord) {
                        if (dupeNode.octaveStates[idx] !== null) {
                            isThisOctaveActive = true;
                            break;
                        }
                    }

                    ctx.fillStyle = isThisOctaveActive ? NODE_COLORS[l].a : '#b3b3b3'; 
                    ctx.strokeStyle = '#999';
                    ctx.lineWidth = 1;
                    ctx.fill();
                    ctx.stroke();

                    if (hoveredOctave.node === n && hoveredOctave.octaveIndex === idx) {
                        const [nodeNum, nodeDen] = n.ratio;
                        const [multNum, multDen] = OCTAVE_MULTIPLIER_FRACS[idx];
                        const [simpNum, simpDen] = simplifyFraction(nodeNum * multNum, nodeDen * multDen);
                        const fracText = `${simpNum}/${simpDen}`;
                        
                        let hoverText = '';
                        if (displayMode === 'hz') {
                            const freq = fundamental * (nodeNum / nodeDen) * multiplier;
                            hoverText = `${fracText} (${freq.toFixed(1)} Hz)`;
                        } else {
                            hoverText = fracText;
                        }

                        ctx.fillStyle = '#555';
                        ctx.font = '8px "Helvetica Neue"';
                        ctx.textAlign = 'left';
                        ctx.textBaseline = 'middle';
                        ctx.fillText(hoverText, x + 5, y);
                    }
                });

                ctx.fillStyle = '#333';
                ctx.textAlign = 'center';
                ctx.font = '9px "Helvetica Neue"';
                let labelText;
                if (hoveredNode === n) {
                    if (fT === '1/1') {
                        labelText = 'Primes = 1';
                    } else {
                        const factors = [...new Set(n.non2Primes_withMultiplicity)].sort((a, b) => a - b);
                        labelText = 'Primes = ' + (factors.length > 0 ? factors.join(', ') : 'None');
                    }
                } else {
                    const baseFreq = fundamental * (n.ratio[0] / n.ratio[1]);
                    labelText = displayMode === 'hz' ? `${baseFreq.toFixed(1)}Hz` : freqToPitchName(baseFreq);
                }
                ctx.fillText(labelText, n.x, n.y + LABEL_Y_OFFSET);
            }

            if (highlightedIntervals.length > 0) {
                ctx.save();
                ctx.strokeStyle = 'red';
                ctx.lineWidth = 3;
                ctx.globalAlpha = 0.85;
                highlightedIntervals.forEach(pair => {
                    const [nodeA, nodeB] = pair;
                    const ax = nodeA.x, ay = nodeA.y;
                    const bx = nodeB.x, by = nodeB.y;

                    const HIGHLIGHT_CIRCLE_RADIUS = NODE_RADIUS + 3;
                    const vecX = bx - ax;
                    const vecY = by - ay;
                    const dist = Math.sqrt(vecX * vecX + vecY * vecY);

                    if (dist === 0) return;

                    const unitX = vecX / dist;
                    const unitY = vecY / dist;

                    const startX = ax + unitX * HIGHLIGHT_CIRCLE_RADIUS;
                    const startY = ay + unitY * HIGHLIGHT_CIRCLE_RADIUS;
                    const endX = bx - unitX * HIGHLIGHT_CIRCLE_RADIUS;
                    const endY = by - unitY * HIGHLIGHT_CIRCLE_RADIUS;
                    
                    if (dist > 2 * HIGHLIGHT_CIRCLE_RADIUS) {
                        ctx.beginPath();
                        ctx.moveTo(startX, startY);
                        ctx.lineTo(endX, endY);
                        ctx.stroke();
                    }

                    ctx.beginPath();
                    ctx.arc(ax, ay, HIGHLIGHT_CIRCLE_RADIUS, 0, 2 * Math.PI);
                    ctx.stroke();

                    ctx.beginPath();
                    ctx.arc(bx, by, HIGHLIGHT_CIRCLE_RADIUS, 0, 2 * Math.PI);
                    ctx.stroke();
                });
                ctx.restore(); 
            }

            ctx.restore();
        });
    }

    /* --- AUDIO & STATE LOGIC --- */
    function deactivateOctave(nD, oI) {
        if (nD && nD.octaveStates && nD.octaveStates[oI]) {
            const { source, env } = nD.octaveStates[oI];
            const now = audioCtx.currentTime;
            env.gain.cancelScheduledValues(now);
            env.gain.setValueAtTime(env.gain.value, now);
            env.gain.linearRampToValueAtTime(0, now + releaseTime);
            source.stop(now + releaseTime + 0.1);
            nD.octaveStates[oI] = null;
        }
    }
    
    function toggleOctave(nD, oI) {
        if (!nD) return;
        const octaveIndex = oI;

        // --- DEACTIVATION ---
        if (nD.octaveStates[octaveIndex] !== null) {
            deactivateOctave(nD, octaveIndex);
            drawLattice(); 
            return;
        }
        
        // --- ACTIVATION ---
        const now = audioCtx.currentTime;
        const baseFreq = fundamental * (nD.ratio[0] / nD.ratio[1]);
        const targetFreq = baseFreq * OCTAVE_MULTIPLIERS[octaveIndex];
        const env = audioCtx.createGain();
        env.connect(lowPassFilter);
        env.gain.setValueAtTime(0, now);
        env.gain.linearRampToValueAtTime(1, now + attackTime);
        const source = audioCtx.createOscillator();
        source.type = waveform;
        source.frequency.setValueAtTime(targetFreq, now);
        source.connect(env);
        source.start(now);
        nD.octaveStates[octaveIndex] = { source, env };
        drawLattice();
    }
    
    function deactivateAllOctaves(nD){if(!nD)return;let ch=false;nD.octaveStates.forEach((o,i)=>{if(o!==null){deactivateOctave(nD,i);ch=true;}});if(ch)drawLattice();}
    window.deactivateAll=function(){nodes.forEach(f=>deactivateAllOctaves(f));}


    // --- PAN/ZOOM FUNCTIONS ---

    function setZoom(newUiFactor) {
        const minUiFactor = parseFloat(document.getElementById('zoom-slider').min);
        const maxUiFactor = parseFloat(document.getElementById('zoom-slider').max);
        
        // Constrain the UI factor
        uiZoomFactor = Math.min(maxUiFactor, Math.max(minUiFactor, newUiFactor));
        // Calculate the actual zoom level: BASE_INTERNAL_ZOOM * UI Factor
        zoomLevel = BASE_INTERNAL_ZOOM * uiZoomFactor; 

        document.getElementById('zoom-slider').value = uiZoomFactor.toFixed(2);
        document.getElementById('zoom-val').textContent = uiZoomFactor.toFixed(2); // Display the UI factor
        drawLattice();
    }
    
    function getMouseWorldPos(e) {
        const r = canvas.getBoundingClientRect();
        const mX = e.clientX - r.left;
        const mY = e.clientY - r.top;
        const wX = (mX - r.width / 2 - pan.x) / zoomLevel + centerX;
        const wY = (mY - r.height / 2 - pan.y) / zoomLevel + centerY;
        return { worldX: wX, worldY: wY, screenX: mX, screenY: mY };
    }

    function handleZoom(event) {
        event.preventDefault(); // Prevent default scroll behavior
        
        const canvasRect = canvas.getBoundingClientRect();
        // Cursor position relative to the canvas center (in screen coordinates)
        const cursorX = event.clientX - canvasRect.left - canvasRect.width / 2;
        const cursorY = event.clientY - canvasRect.top - canvasRect.height / 2;
        
        // Check for pinch/trackpad zoom (ctrlKey is often true for trackpad pinch events)
        if (event.ctrlKey || event.metaKey) {
            const oldZoomLevel = zoomLevel; // Capture current actual zoom level
            const oldUiFactor = uiZoomFactor;

            const zoomDelta = event.deltaY; 
            const zoomChangeFactor = -zoomDelta * 0.005; // Base change, e.g., 0.02
            const newUiFactor = oldUiFactor * (1 + zoomChangeFactor);

            setZoom(newUiFactor); // Updates zoomLevel, uiZoomFactor, and UI

            // Calculate new pan required to keep the point under the cursor after zoom
            const ratio = zoomLevel / oldZoomLevel;
            pan.x -= cursorX * (1 - ratio);
            pan.y -= cursorY * (1 - ratio);

        } else {
            // Two-finger pan (Scroll)
            pan.x -= event.deltaX * 0.6;
            pan.y -= event.deltaY * 0.6;
        }

        drawLattice();
    }
    
    function handlePanStart(event) {
        if (event.button === 0) { // Left click for drag pan
            isDragging = true;
            lastMouseX = event.clientX;
            lastMouseY = event.clientY;
            canvas.style.cursor = 'grabbing';
        }
    }

    function handlePanMove(event) {
        if (!isDragging) return;

        const dx = event.clientX - lastMouseX;
        const dy = event.clientY - lastMouseY;

        // Update pan
        pan.x += dx; 
        pan.y += dy;

        lastMouseX = event.clientX;
        lastMouseY = event.clientY;
        drawLattice();
    }

    function handlePanEnd() {
        isDragging = false;
        canvas.style.cursor = 'default';
    }
    
    function findNodeAt(x, y) {
        const { worldX, worldY } = getMouseWorldPos({clientX: x, clientY: y});

        // Only iterate over nodes that are currently visible (from the cache)
        // Reverse iteration prioritizes nodes drawn last (on top, for octaves)
        for (const n of [...visibleNodesCache].reverse()) {
            
            // Check octave selectors
            for (let i = 0; i < OCTAVE_MULTIPLIERS.length; i++) {
                const octaveX = n.x + OCTAVE_SELECTOR_X_OFFSET;
                const octaveY = n.y - (2 * OCTAVE_SELECTOR_Y_STEP) + (i * OCTAVE_SELECTOR_Y_STEP);
                const octDistSq = Math.pow(octaveX - worldX, 2) + Math.pow(octaveY - worldY, 2);
                if (octDistSq < Math.pow(OCTAVE_SELECTOR_RADIUS * 3, 2)) { 
                    return { node: n, type: 'octave', index: i };
                }
            }

            // Check main node circle
            const distSq = Math.pow(n.x - worldX, 2) + Math.pow(n.y - worldY, 2);
            if (distSq < Math.pow(NODE_RADIUS, 2)) {
                return { node: n, type: 'node', index: 2 }; // Index 2 is the 1:1 octave
            }
        }
        return null;
    }


    /* --- EVENT HANDLERS --- */
    function populateIntervalSelector() {
        const select = document.getElementById('interval-select');
        select.innerHTML = '<option value="">Select a preset...</option>'; 
        for (const group in PRESET_INTERVALS) {
            const optgroup = document.createElement('optgroup');
            optgroup.label = group;
            for (const name in PRESET_INTERVALS[group]) {
                const option = document.createElement('option');
                option.textContent = name;
                option.value = PRESET_INTERVALS[group][name];
                optgroup.appendChild(option);
            }
            select.appendChild(optgroup);
        }
    }
    
    function handleCanvasClick(event) {
        if (isDragging) return; 
        
        const hit = findNodeAt(event.clientX, event.clientY);
        if (hit) {
            if (hit.type === 'node') {
                const n = hit.node;
                const anyActive = n.octaveStates.some(o => o !== null);
                if (anyActive) {
                    // If any octave is active, deactivate all octaves
                    deactivateAllOctaves(n);
                } else {
                    // If nothing is active, trigger the central pitch (index 2: 1:1 multiplier)
                    toggleOctave(n, 2); 
                }
            } else if (hit.type === 'octave') {
                toggleOctave(hit.node, hit.index); 
            }
        }
    }

    function handleCanvasMouseMove(event) {
        if (isDragging) {
            handlePanMove(event);
            return;
        }

        const hit = findNodeAt(event.clientX, event.clientY);
        
        let newHoveredNode = null;
        let newHoveredOctave = { node: null, octaveIndex: -1 };
        let redraw = false;

        if (hit) {
            if (hit.type === 'node') {
                newHoveredNode = hit.node;
                canvas.style.cursor = 'pointer';
            } else if (hit.type === 'octave') {
                newHoveredOctave = { node: hit.node, octaveIndex: hit.index };
                canvas.style.cursor = 'crosshair';
            }
        } else {
            canvas.style.cursor = 'default';
        }

        if (hoveredNode !== newHoveredNode || 
            hoveredOctave.node !== newHoveredOctave.node || 
            hoveredOctave.octaveIndex !== newHoveredOctave.octaveIndex) {
            
            hoveredNode = newHoveredNode;
            hoveredOctave = newHoveredOctave;
            redraw = true;
        }

        if (redraw) {
            drawLattice();
        }
    }


    // --- INITIALIZATION & BINDINGS ---
    function setupEventListeners() {
        // --- Pan and Zoom ---
        canvas.addEventListener('wheel', handleZoom, { passive: false }); 
        
        canvas.addEventListener('mousedown', handlePanStart); 
        window.addEventListener('mouseup', handlePanEnd);     
        window.addEventListener('mousemove', handlePanMove);  
        
        // --- Other Interactions ---
        canvas.addEventListener('click', handleCanvasClick);
        canvas.addEventListener('mousemove', handleCanvasMouseMove);
        window.addEventListener('resize', setupCanvas); 

        // --- UI Control Bindings ---
        document.getElementById('zoom-slider').addEventListener('input', (e) => setZoom(parseFloat(e.target.value)));
        document.getElementById('waveform').addEventListener('change', (e) => { waveform = e.target.value; });
        document.getElementById('volume').addEventListener('input', (e) => { 
            masterGain.gain.setValueAtTime(parseFloat(e.target.value), audioCtx.currentTime); 
            document.getElementById('volume-val').textContent = parseFloat(e.target.value).toFixed(2);
        });
        document.getElementById('attack').addEventListener('input', (e) => { 
            attackTime = parseFloat(e.target.value); 
            document.getElementById('attack-val').textContent = attackTime.toFixed(2);
        });
        document.getElementById('decay').addEventListener('input', (e) => { 
            releaseTime = parseFloat(e.target.value); 
            document.getElementById('decay-val').textContent = releaseTime.toFixed(2);
        });
        document.getElementById('filter-freq').addEventListener('input', (e) => { 
            lowPassFilter.frequency.setValueAtTime(parseFloat(e.target.value), audioCtx.currentTime); 
            document.getElementById('filter-freq-val').textContent = e.target.value;
        });
        document.getElementById('filter-q').addEventListener('input', (e) => { 
            lowPassFilter.Q.setValueAtTime(parseFloat(e.target.value), audioCtx.currentTime); 
            document.getElementById('filter-q-val').textContent = parseFloat(e.target.value).toFixed(1);
        });

        document.querySelectorAll('input[name="pitch-display"]').forEach(radio => {
            radio.addEventListener('change', (e) => {
                displayMode = e.target.value;
                const iE=document.getElementById('fundamental-input');
                const lE=document.getElementById('fundamental-label');
                if(displayMode==='hz'){lE.textContent='Fundamental (Hz):';iE.value=fundamental.toFixed(2);}else{lE.textContent='Fundamental (Pitch + Cents):';iE.value=freqToPitchName(fundamental);}
                drawLattice();
            });
        });

        document.getElementById('prime-limit-select').addEventListener('change', updatePrimeFiltersFromLimit);
        document.getElementById('parent-limit-select').addEventListener('change', updateLattice);
        document.getElementById('prime-filters').addEventListener('change', handlePrimeFilterChange);
        document.getElementById('show-harmonics').addEventListener('change', updateLattice);
        document.getElementById('show-subharmonics').addEventListener('change', updateLattice);

        document.getElementById('interval-select').addEventListener('change', handlePresetIntervalChange);
        document.getElementById('locate-interval-btn').addEventListener('click', locateInterval);
        document.getElementById('clear-interval-btn').addEventListener('click', clearHighlightedIntervals);
        
        document.querySelectorAll('.control-group > h2').forEach(header => {
            header.addEventListener('click', (e) => {
                e.currentTarget.parentNode.classList.toggle('collapsed');
            });
        });

        // Initialize display values for controls
        document.getElementById('zoom-val').textContent = uiZoomFactor.toFixed(2); // Display 1.0
        document.getElementById('volume-val').textContent = masterGain.gain.value.toFixed(2);
        document.getElementById('attack-val').textContent = attackTime.toFixed(2);
        document.getElementById('decay-val').textContent = releaseTime.toFixed(2);
        document.getElementById('filter-freq-val').textContent = lowPassFilter.frequency.value;
        document.getElementById('filter-q-val').textContent = lowPassFilter.Q.value.toFixed(1);
    }
    
    function setupCanvas() {
        const dpr = window.devicePixelRatio || 1;
        const container = document.getElementById('container');
        // Set canvas width/height attributes (used by ctx)
        canvas.width = container.clientWidth * dpr;
        canvas.height = container.clientHeight * dpr;
        // Set CSS width/height (what the user sees)
        canvas.style.width = container.clientWidth + 'px';
        canvas.style.height = container.clientHeight + 'px';
        ctx.scale(dpr, dpr); // Scale context for high DPI displays
        drawLattice();
    }

    function setFundamental() {
        let newFreq = parseFloat(document.getElementById('fundamental-input').value);
        if (displayMode !== 'hz') {
            const pitchFreq = pitchNameToFreq(document.getElementById('fundamental-input').value.trim());
            if (pitchFreq !== null) newFreq = pitchFreq;
        }

        if (isNaN(newFreq) || newFreq <= 0) {
            newFreq = 440;
            if(displayMode === 'hz') document.getElementById('fundamental-input').value = '440';
        }
        
        fundamental = newFreq;
        if(displayMode === 'pitch') {
            document.getElementById('fundamental-input').value = freqToPitchName(fundamental);
        } else {
            document.getElementById('fundamental-input').value = fundamental.toFixed(2);
        }

        deactivateAll();
        drawLattice();
    }

    function updateLattice() {
        showHarmonics = document.getElementById('show-harmonics').checked;
        showSubharmonics = document.getElementById('show-subharmonics').checked;

        const generationMode = document.getElementById('parent-limit-select').value;
        
        // Pass nodes with active audio state to preserve them
        const nodesToPreserve = nodes ? nodes.filter(n => n.octaveStates.some(o => o !== null)) : [];
        
        const result = generateLatticeNodes(generationMode, nodesToPreserve);
        nodes = result.nodes;
        existingRatios = result.existingRatios;
        drawLattice();
    }
    
    const pL={'3':[3],'5':[3,5],'7':[3,5,7],'11':[3,5,7,11],'13':[3,5,7,11,13],'17':[3,5,7,11,13,17],'19':[3,5,7,11,13,17,19],'23':[3,5,7,11,13,17,19,23],'29':[3,5,7,11,13,17,19,23,29],'31':[3,5,7,11,13,17,19,23,29,31]};

    function updatePrimeFiltersFromLimit(e) {
        const limit = e.target.value;
        const checkboxes = document.querySelectorAll('#prime-filters input[type="checkbox"]');
        let newActivePrimes = new Set();
        
        if (limit !== 'custom') {
            const primesToSet = pL[limit] || [];
            checkboxes.forEach(cb => {
                const prime = parseInt(cb.dataset.prime);
                const shouldBeChecked = primesToSet.includes(prime);
                cb.checked = shouldBeChecked;
                if (shouldBeChecked) newActivePrimes.add(prime);
            });
            activePrimes.clear();
            newActivePrimes.forEach(p => activePrimes.add(p));
        } else {
            // Re-read current custom state
            activePrimes.clear();
            checkboxes.forEach(cb => {
                if (cb.checked) {
                    const prime = parseInt(cb.dataset.prime);
                    if (prime > 2) activePrimes.add(prime);
                }
            });
        }
        updateLattice();
    }

    function handlePrimeFilterChange(e) {
        const prime = parseInt(e.target.dataset.prime);
        const isChecked = e.target.checked;
        
        if (prime > 2) {
            if (isChecked) {
                activePrimes.add(prime);
            } else {
                activePrimes.delete(prime);
            }
        }
        document.getElementById('prime-limit-select').value = 'custom';
        updateLattice();
    }

    function handlePresetIntervalChange(e) {
        const value = e.target.value;
        if (value) {
            const [num, den] = value.split('/').map(n => parseInt(n));
            document.getElementById('interval-num1').value = num;
            document.getElementById('interval-num2').value = den;
        } else {
            document.getElementById('interval-num1').value = '';
            document.getElementById('interval-num2').value = '';
        }
    }
    
    document.getElementById('interval-num1').addEventListener('input', () => { document.getElementById('interval-select').value = ''; });
    document.getElementById('interval-num2').addEventListener('input', () => { document.getElementById('interval-select').value = ''; });


    function locateInterval() {
        let num = parseInt(document.getElementById('interval-num1').value);
        let den = parseInt(document.getElementById('interval-num2').value);

        if (isNaN(num) || isNaN(den) || num <= 0 || den <= 0) {
            alert("Please enter valid, positive numbers for the ratio.");
            return;
        }

        const targetInterval = normalizeIntervalRatio(num, den);
        highlightedIntervals = [];

        const visibleNodes = nodes.filter(shouldNodeBeVisible);

        for (let i = 0; i < visibleNodes.length; i++) {
            for (let j = i + 1; j < visibleNodes.length; j++) {
                const nodeA = visibleNodes[i];
                const nodeB = visibleNodes[j];

                const intervalNum = nodeA.ratio[0] * nodeB.ratio[1];
                const intervalDen = nodeA.ratio[1] * nodeB.ratio[0];
                const nodeInterval = normalizeIntervalRatio(intervalNum, intervalDen);

                if (nodeInterval[0] === targetInterval[0] && nodeInterval[1] === targetInterval[1]) {
                    highlightedIntervals.push([nodeA, nodeB]);
                }
            }
        }
        drawLattice();
        if (highlightedIntervals.length === 0) {
            alert(`No visible pairs found for the interval ${num}:${den}.`);
        }
    }

    function clearHighlightedIntervals() {
        highlightedIntervals = [];
        document.getElementById('interval-select').value = '';
        document.getElementById('interval-num1').value = '';
        document.getElementById('interval-num2').value = '';
        drawLattice();
    }

    // --- EXECUTION ---
    function initialize() {
        const result = generateLatticeNodes(document.getElementById('parent-limit-select').value);
        nodes = result.nodes;
        existingRatios = result.existingRatios;
        setupEventListeners();
        populateIntervalSelector();
        setupCanvas(); 
        setFundamental(); 
    }

    initialize();
  </script>
</body>
</html>
